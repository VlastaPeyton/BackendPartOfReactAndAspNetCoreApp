Klasa A ima navigational property(attribute) tipa B ako:
	- A i B su tabele tj def u ApplicationDbContext kao tabele 
	- Property je tipa klase B + A sadrzi BId => EF Core automatski FK-PK one-to-one napravi
	- Property je List/IEnumerable<B> + B sadrzi A.Id => EF Core automatski FK-PK one-to-many napravi

Za navigtional property:
	- Koristim Include (Eager loading) u LINQ klase A da dohvatim i polje B ako klasa A ima polje B, jer B ne moze biti kolona nikako 
	- Ako je circular reference (B sadrzi AId i A sadrzi BId) => problem kod JSON serializer => U Program.cs ugasi rucno 
	- Uvek koristim "?" ili "=defaul!" za navigation property, jer ako ocitavannja klase A ne ocitam i B, onda B  bice null sto je u redu, ali sa "?"/"=default!" compiler ne kuka
	- Ako je B tipa IEnumerable, default uvek "new()" dodelim
	- Ako je B tipa klase -> a u OnModelCreating ima HasForeignKey.IsRequired, onda required B ili B =null! 
						  -> a u OnModelCreating nema IsRequired, onda B? 
	
	- Tokom kreiranja A, prosledjujem i B u konstruktoru samo ako B vec ne postoji u bazi ! 

Klasa A ima Owned entity property tipa B ako:
	- A je tabela u bazi
	- Property je tipa klase B i :
		- ima annotation [Owned] ili u OnModelCreating je upisan pomocu "builder.Entity<A>().OwnsOne(...)" 
		- B nije def u ApplicationDbContext kao tabela u bazi
		- B nema Id polje 

Za owned entity:
	- Sva polja iz B bice kolone u A pod nazivom B_field1, B_field2 ...
	- Owned entity klasa se koristi u DDD tj unutar Agregate 
	- Owned entity je Value Object ustvari

EF Core does not fetch navigational property automatcially, thats why Eager / Lazy / Explicit loading come into play:
	1. Eager:
		Include/ThenInclude u LINQ koristim, jer znam da mi treba B property istovremeno kada ocitavam A tabelu.
		Eager loading reduces round trips to DB as Include is SQL JOIN command, rather than separate queries.
		Ako je navigation attribute B ogromno i retko se koristi, ne isplati se ovaj pristup. 
		Ovo smanjuje br round trips ka bazi.

	2. Lazy:
		Lazy loading unosi N+1 problem, jer ako je B lista, onda ce za svaki element pozivati bazu. 
		Kada mi treba B polje na zahtev. 
		Navigation attribute B must be virtual.
		U OnModelCreating treba "UseLazyLoadingProxies".

	3. Explicit:
		Koristi se keyword "LoadAsync()" na kraju LINQ.